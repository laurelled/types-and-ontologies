\chapter[Stato dell'arte]{Stato dell'arte}
\label{chap:State-of-art}
Il Web Semantico è di natura un campo d'interesse interdisciplinare: oltre ai poli di ricerca delle discipline informatiche, il cui coinvolgimento può essere riassunto nel miglioramento delle tecnologie e principi che costituiscono il Web Semantico, esistono contesti in cui si vorrebbe utilizzare questo nuovo paradigma Web come un semplice strumento. Per fare un esempio, quando verso il 2006 le ontologie nello stato in cui erano si sono dimostrate difficili da mantere e riutilizzare, si è sviluppato un insieme di principi per rendere più superficiale le annotazioni semantiche, chiamato \textit{Linked Open Data} \cite{hitzler2021review}. Essenzialmente l'organizzazione della conoscenza consisteva di grafi RDF che potevano essere collegati tra di loro qualora fossero presenti identificatori IRI (che identificano un nodo) in comune. In questo modo la collezione di tutti i grafi RDF collegati poteva essere inteso come un singolo grande grafo RDF, permettendo una maggiore integrazione e gestione dei dati rispetto alla gestione di un'ontologia.\\
Negli ultimi due decenni, il Web Semantico si è arricchito di tecnologie, strumenti e metodologie grazie agli sforzi di ricercatori e aziende: contributi fondamentali dai campi del Natural Language Processing  e del Machine Learning hanno permesso di sviluppare metodi per semi-automatizzare compiti complessi, come la costruzione e riutilizzo di ontologie partendo da testi in linguaggio naturale o di aggiungere relazioni mancanti tra dati; nel 2012 Google ha lanciato il suo "knowledge graph", che si è diffuso rapidamente come tecnica di modellazione della conoscenza nel Web Semantico. BrevementeSeguendo le necessità degli utilizzatori, quindi, si è formata un'ampia collezione di letteratura e tecniche per ogni settore d'applicazione. Per i lettori interessati alle influenze e stato attuale del Web Semantico, un'ottima e recente recensione può essere trovata qui \cite{hitzler2021review}.\\
L'obiettivo finale di un Web accessibile agli agenti intelligenti è sempre più vicino, ma rimangono ancora dei problemi aperti.
\begin{description}
	\item[Mancanza di definizioni formali.] Ad esempio, anche se è stato presentato per la prima volta 11 anni fa e sia largamente utilizzato, non è ancora stata data una definizione formale di cosa sia un knowledge graph, anche se sforzi verso questo risultato sono stati proposti \cite{ehrlinger2016towards}. La ragione principale che dovrebbe spingere la comunità del Web Semantico nel trovare delle definizione comuni è la disambiguazione dei termini, che funge da deterrente per la diffusione negli ambiti accademici e aziendali dei concetti e tecnologie del campo di ricerca. La poca consolidazione del vocabolario ostacola l'apprendimento delle persone interessate a svolgere ricerca nell'ambito del Web Semantico, rendendolo meno attraente.
\end{description}

\section{Formalizzazione della terminologia}
Il riutilizzo delle ontologie è ancora un problema attuale, su cui molti ricercatori stanno trovando modi per sfruttare dei metodi provenienti da campi differenti (es. scienze cognitive, NLP e machine learning). Da questi sforzi sono nate metodologie di sviluppo di ontologie che incentivano il riutilizzo \cite{...},framework che combinano tecniche di integrazione e di NLP \cite{...} e algoritmi provenienti da paradigmi di rappresentazione di conoscenza paralleli alle ontologie \cite{...}. Tra tutti i contributi significativi citati, e tanti altri per cui non c’è stato tempo di leggere, soltanto Megan Katsumi e Michael Grüninger, al meglio delle nostre conoscenze, hanno evidenziato un problema fondamentale inerente a questo campo. Nel loro lavoro \cite{...}, i due autori sottolineano la mancanza di una definizione formale, di un limite esplicito e accettato di cosa sia il riutilizzo, e di cosa non sia. Questo porta ad ostacolare la sua diffusione. La mancanza di formalizzazione non riguarda soltanto la definizione delle discipline, ma anche sui concetti fondamentali su cui si basano. Un esempio che proviene dal campo dell’evoluzione ontologica1 è la definizione formale delle operazioni che vanno a modificare un’ontologia. Diversi sforzi verso una definizione comune e accettata dalla comunità di questa disciplina sono stati fatti. Ad esempio uno dei tentativi meno recenti, da noi considerato significativo, di Thomas Sindt \cite{...} di fornire un Abstact Data Type (ADT), ossia un tipo di dato che astrae dalla sua realizzazione. All'interno dell'ADT vengono definite delle operazioni su di esso che caratterizzano il suo significato. \cite{...} sfrutta questa astrazione per la rappresentazione delle ontologie basate su $\mathcal{ALC}$ (si vedano i concetti preliminari \autoref{sec:logicaALCOIQ}) tramite liste e le relative operazioni di modifica. La semantica delle operazioni è resa esplicita dalla definizione delle pre e post-condizioni per ognuna di esse. Questo consente di:
tracciare le versioni e il dominio d’interesse descritto;
risalire, per le modifiche lecite, alle versioni precedenti dell’ontologia andando ad invertire un numero arbitrario di operazioni.
Queste due operazioni, fondamentali nella gestione del ciclo di vita di un’ontologia, sarebbero state di facile implementazione attraverso l’ADT definito da Sindt, avvantaggiando le aziende interessate alle ontologie. Anche se non ha riscosso molto successo, l’idea di Sindt potrebbe essere riutilizzata attraverso i linguaggi funzionali, dato che le liste sono una delle strutture dati ricorsive manipolabili facilmente con essi. Continuare a spiegare perchè…
Da aggiungere parte intermedia per passare dall’articolo sopra, che parla di formalizzazione di operazioni, a quello sotto, che parla di comparazione tra ontologie e sistemi di tipo in chiave di ontology evolution.


\section{Riutilizzabilità delle ontologie}
\label{sec:OntoReuse}
La trasformazione delle ontologie è intrinseca negli obiettivi del Web Semantico. In una rete di conoscenza in continuo aggiornamento, l'aggiunta di nuovi dati può significare il cambiamento della modellazione dei concetti del dominio d'interesse, che sia un'aggiunta o sia una sottrazione di questi. Il valore delle ontologie è anche dato dalla loro riusabilità: è relativamente facile estenderle, aggiungendo nuovi concetti, oppure utilizzarle per generarne delle nuove basi di conoscenza. Il riutilizzo delle ontologie promuove l'interoperabilità delle fonti di dati e facilita il processo di creazione di nuove ontologie e l'integrazione dei dati, ed è fortemente legato ad altri processi di ingegneria delle ontologie.
\subsection{Cosa si intende per riutilizzo nella letteratura}
Tra le poche definizione di riutilizzo di un'ontologia la più completa, seppur informale, può essere considerata "il processo in cui la conoscenza (ontologica) disponibile viene utilizzata come input per generare nuove ontologie" (tradotto da \cite{...}). Carriero et. al. \cite{...} danno un ottimo sguardo d'insieme sullo stato dell'arte, benefici, lacune e criticità dei vari approcci al riutilizzo di ontologie, dando un'analisi completa per i lettori interessati ad approfondire.
Esistono due strategie principali per il riutilizzo di ontologie: 
Il riuso diretto, che può essere portato avanti tramite l'assioma owl:imports, che importa intere ontologie, oppure tramite la sola inclusione di termini già definiti (facendo riferimento all'ontologia sorgente tramite rdfs:isDefinedBy). Nel primo approccio, le informazioni espresse dalle ontologie riutilizzate sono incluse nella nuova ontologia, mentre nel secondo il compito di chiarire la semantica dei termini è “delegata” all'ontologia riutilizzata.
Il riuso indiretto fa sì che i termini presi da ontologie esistenti si comportino da contesto (o template) per la definizione dei nuovi termini o proprietà della nuova ontologia, permettendo di allinearli semanticamente attraverso assiomi come rdfs:subClassOf o owl:equivalentProperty.
Per chiarire il punto 2, il processo di allineamento di ontologie si basa sulla creazione di riferimenti fra due ontologie. Questo permette di mantenere separate le ontologie ma di restare coerenti fra di loro. \cite{...}
Per generare un ontologia prendendo come base altre basi di conoscenza, si sono diffusi principalmente due metodi:
Ontology integration (anche detto modular composition): il processo di generazione di un'unica ontologia su un argomento da due o più ontologie esistenti e diverse su argomenti diversi. I diversi argomenti delle diverse ontologie possono essere essere correlati \cite{...}. Viene chiamato composizione modulare perché le ontologie “sorgenti” non trattano (solo) dello stesso argomento che stiamo cercando di descrivere con l'ontologia “risultante”.
Ontology merging (anche detto fusion): processo in cui singoli concetti, assiomi e affermazioni di ontologie “sorgenti” vengono fusi insieme in un nuovo modello. Le ontologie originali hanno domini simili o sovrapposti, ma sono diverse e non revisioni della stessa ontologia. Sono necessarie attività di normalizzazione per confrontare uniformemente i concetti rappresentati da una base di conoscenza rispetto ad un'altra. \cite{.., ..}
\subsection{Problemi}
Scarso orientamento al riutilizzo In \cite{...}, in cui gli autori comparano le tendenze di riutilizzo di ontologie contenute nella repository LOV (Linked Open Vocabularies) rispetto ai risultati ottenuti in lavori precedenti, viene rilevato che circa un terzo delle ontologie registrate non è stato possibile ottenerle correttamente. Le possibili cause rilevate dagli autori sono una mancanza di disponibilità di condividere (soprattutto da parte delle aziende) le ontologie sviluppate, assieme a una scarsa manutenzione orientata al riutilizzo di esse.
Aggiungere altri, riconsultare Carriero e Choi
Formalizzazione della terminologia
Il riutilizzo delle ontologie è ancora un problema attuale, su cui molti ricercatori stanno trovando modi per sfruttare dei metodi provenienti da campi differenti (es. scienze cognitive, NLP e machine learning). Da questi sforzi sono nate metodologie di sviluppo di ontologie che incentivano il riutilizzo \cite{...},framework che combinano tecniche di integrazione e di NLP \cite{...} e algoritmi provenienti da paradigmi di rappresentazione di conoscenza paralleli alle ontologie \cite{...}. Tra tutti i contributi significativi citati, e tanti altri per cui non c'è stato tempo di leggere, soltanto Megan Katsumi e Michael Grüninger, al meglio delle nostre conoscenze, hanno evidenziato un problema fondamentale inerente a questo campo. Nel loro lavoro \cite{...}, i due autori sottolineano la mancanza di una definizione formale, di un limite esplicito e accettato di cosa sia il riutilizzo, e di cosa non sia. Questo porta ad ostacolare la sua diffusione. La mancanza di formalizzazione non riguarda soltanto la definizione delle discipline, ma anche sui concetti fondamentali su cui si basano. Un esempio che proviene dal campo dell'evoluzione ontologica1 è la definizione formale delle operazioni che vanno a modificare un'ontologia. Diversi sforzi verso una definizione comune e accettata dalla comunità di questa disciplina sono stati fatti. Ad esempio uno dei tentativi meno recenti, da noi considerato significativo, di Thomas Sindt \cite{...} di fornire un ADT2 per la rappresentazione delle ontologie basate su ALC1 tramite liste e le relative operazioni di modifica. La semantica delle operazioni è resa esplicita dalla definizione delle pre e post-condizioni per ognuna di esse. Questo consente di:
tracciare le versioni e il dominio d'interesse descritto;
risalire, per le modifiche lecite, alle versioni precedenti dell'ontologia andando ad invertire un numero arbitrario di operazioni.
Queste due operazioni, fondamentali nella gestione del ciclo di vita di un'ontologia, sarebbero state di facile implementazione attraverso l'ADT definito da Sindt, avvantaggiando le aziende interessate alle ontologie. Anche se non ha riscosso molto successo, l'idea di Sindt potrebbe essere riutilizzata attraverso i linguaggi funzionali, dato che le liste sono una delle strutture dati ricorsive manipolabili facilmente con essi. Continuare a spiegare perchè…
Da aggiungere parte intermedia per passare dall'articolo sopra, che parla di formalizzazione di operazioni, a quello sotto, che parla di comparazione tra ontologie e sistemi di tipo in chiave di ontology evolution.


\section{Ontologie e sistemi di tipo}
Nell'approfondire le ontologie si può pensare di paragonarle ai sistemi di tipi dei linguaggi di programmazione. La similarità che il lettore potrebbe scorgere deriva dal fatto che le ontologie, nel contesto del Web Semantico, hanno lo scopo di raggruppare sotto diversi insiemi, chiamati \textit{concetti}, i nodi dei grafi RDF. Riprendendo l'esempio \eqref{eq:T1.1} della \autoref{sec:KB}, se una tripla descrive che il nodo \textsl{bob} sia in relazione hasName con un altro valore, allora automaticamente possiamo dire \textsl{bob} che appartiene all'interpretazione del concetto Person. Prima di considerare come questo si potrebbe tradurre nella terminologia dei sistemi di tipi, ricordiamo la definizione comunemente accettata di un sistema di tipi \cite{pierceTypesBook}:
\begin{definition}
	Un sistema di tipi è un metodo sintattico trattabile, in grado di dimostrare l'assenza di determinati comportamenti nei programmi mediante la classificazione di espressioni fatta in base alla natura dei valori che esse elaborano.
\end{definition}
\noindent
In altre parole, esso raggruppa espressioni che producono valori simili in \textit{insiemi}, chiamati \textit{tipi}, e permette di stabilire quando un valore è permesso oppure no attraverso delle \textsl{regole di derivazione}. Riprendendo l'esempio precedente, allora, in un sistema di tipi potremmo rappresentare la stessa cosa aggiungendo una regola di derivazione per un termine che abbia la stessa proprietà di essere in relazione \textsl{hasName} con un altro valore.\\
In effetti, questa confronto fra ontologie e la parte dichiarativa di un programma, in particolare il sistema di tipi non è nuova \cite{moten2015SWTypeSystem, despeyroux2008evolution}, ma non ha nemmeno suscitato l'interesse dei ricercatori del Web Semantico, ad eccezione di alcuni autori che già operano nelle discipline teoriche dell'informatica applicate \cite{dapoigny2011typetheoryKR, leinbergerphdthesis, ciobanu2016typeFoundationforRDFS}. Una domanda, ancora senza interrogativo, è la motivazione dietro a questo scarso interesse.
In \cite{despeyroux2008evolution} il confronto proposto tra un'ontologia e un sistema di tipi è particolarmente interessante per le conclusioni tratte. Per rafforzare questa comparazione, viene affrontata l'analisi delle modifiche svolte durante l'evoluzione di un'ontologia, relazionandola con il processo di type-checking tipico dei sistemi di tipi.

\begin{figure}
	\begin{minipage}[t]{0.45\textwidth}
			\textbf{Concepts}: \textit{Person, Trainee,\\
			PhdStudent, Manager, Researcher,\\
			Director, Team,
			Project;}
			\begin{align}
			\textit{Researcher}\ &\text{is-a}\ \textit{Manager};&\\
			\textit{Director}\ &\text{is-a}\ \textit{Manager};&\\
			\textit{Manager}\ &\text{is-a}\ \textit{Person};&\\
			\textit{PhdStudent}\ &\text{is-a}\ \textit{Person};&\\
			\textit{Trainee}\ &\text{is-a}\ \textit{Person};&
			\end{align}
			
			\textbf{Properties}: work, manage;\\
			Person work Team;\\
			Manager manage Project;\\

		\textbf{Semantic annotations}\\
			(r1 work v1) (r1 type \textit{Person})\\
			(r2 work v2) (r2 type \textit{PhdStudent})\\
			(r3 work v3) (r3 type \textit{Manager})\\
			(r4 manage v4) (r4 type \textit{Manager})\\
			(r5 work v5) (r5 type \textit{Researcher})\\
			(r6 manage v6) (r6 type \textit{Researcher})\\
			(r7 work v7) (r7 type \textit{Director})\\
			(r8 manage v8) (r8 type \textit{Director})\\

	\end{minipage}
	\hspace{0.05\textwidth}
	\begin{minipage}[t]{0.45\textwidth}
		
			\textbf{Types}: \textit{Person}, \textit{PhdStudent}, \textit{Trainee}, \textit{Manager}, \textit{Researcher},\textit{Director}, \textit{Team}, \textit{Project} : Type;
			\begin{align}
			PhdStudent &\le Person;\\
			Trainee &\le Person;\\
			Manager &\le Person;\\
			Researcher &\le Manager;\\
			Director &\le Manager;
		\end{align}
			work : \textit{Person} $\to$ \textit{Team};\\
			manage : \textit{Manager} $\to$ \textit{Project};\\\\\\
			\textbf{Typing relations}\\
			r1 : \textit{Person};\\
			r2 : \textit{PhdStudent};\\
			r3, r4 : \textit{Manager};\\
			r5, r6 : \textit{Researcher};\\
			r7, r8 : \textit{Director};\\
			v1, v2, v3, v5, v7 : \textit{Team};\\
			v4, v6, v8 : \textit{Project};\\
	\end{minipage}
	\captionsetup{justification=Centering}
	\caption{confronto tra una dichiarazione di un'ontologia RDFS (dx) con un sistema di tipo (sx) in cui $\le$ è una relazione di sottotipo}
	\label{fig:confrontotypesystem}
\end{figure}
\noindent
Usando un'ontologia RDFS banale ma esemplificativa, \cite{despeyroux2008evolution} mostra che l'eventuale rimozione di  alcune definizioni di concetti dal T-Box porta le loro istanze presenti nelle annotazioni semantiche (asserzioni A-Box, vedi \autoref{def:ABox}) a rendere inconsistente l'intera annotazione rispetto all'ontologia modificata. Per fare in modo che le annotazioni rimangano consistenti alla base di conoscenza, è necessario individuare quelle inconsistenti e agire su esse.
In \autoref{fig:confrontotypesystem} è possibile vedere l'idea di \cite{despeyroux2008evolution}: se fosse possibile considerare i concetti definiti nell'ontologia come tipi, le relazioni "is-a"\footnote{ricordiamo che in OWL questo si esprime attraverso GCI, assiomi del tipo $C \sqsubseteq D$, con C e D concept expressions} tra i concetti come particolari relazioni di sottotipo e le proprietà come funzioni tra elementi tipati, sarebbe allora possibile trattate le annotazioni semantiche \code{t type \textit{Concept}} come asserzioni di tipo dell'elemento t. Le altre annotazioni sarebbe semplici termini per cui basta dimostrare controllare che i tipi del dominio e codominio della proprietà siano rispettati rispetto alla definizione nell'ontologia. Ad esempio, se abbiamo un'annotazione \code{t work s}, perchè questa sia consistente all'ontologia (sistema di tipi) è necessario che valgano \code{$\text{t}: Person$} e \code{$\text{s}: Team$}. Per dimostrare la consistenza di entrambe le tipologie di annotazioni semantiche sarebbe quindi necessario, perchè questo confronto fra ontologia e sistemo di tipi valga, dimostrare la verità di queste relazioni di tipo, che è proprio quello che fa l'algoritmo di type-checking. Inoltre, se si utilizzasse un algoritmo di type inference \cite{cardoneTypeInference, martellimontanaritypeinference}, ossia un algoritmo per derivare automaticamente le  relazioni di tipo, in base alla definizione di \code{work} e \code{manage} si potrebbero derivare alcune delle relazioni di tipo dichiarate, come ad esempio \code{$\text{r1} : \textit{Person}$}, come farebbe proprio un'ontologia RDFS/OWL.\\
Data la similarità delle ontologie con i sistemi di tipi, \cite{despeyroux2008evolution} arriva alla conclusione che cercare di sfruttare tecniche tipiche dei sistemi di tipi come \textit{polimorfismo}, \textit{overloading} e \textit{parametri di tipo} (per approfondire questi e altri termini consultare \cite{pierceTypesBook}) per creare linguaggi ontologici più espressivi e modulari beneficerebbe il campo della knowledge representation (KR). Questa intuizione è stata portata avanti dalle ricerche di Richard Dapoigny e Patrick Barlatier verso l'applicazione della teoria dei tipi, cioè lo studio dei sistemi di tipi, alla KR. L'approfondimento del loro lavoro richiederebbe però la definizione di conoscenze preliminari che non abbiamo il tempo di definire in questa tesi. Rimandiamo i lettori interessati agli articoli \cite{dapoigny2011typetheoryKR, dapoigny2012typetheoryKR} e alla loro dettagliata bibliografia.
Un aspetto fondamentale che differenzia un'ontologia dai sistemi di tipi è la frequenza della necessità di estensione. La trasformazione delle basi di conoscenza è intrinseca nella natura del Web Semantico, come spiegato nella \autoref{sec:OntoReuse}. Al contrario, l'estensione di un sistema di tipi nei linguaggi di programmazione è di solito dipendente dall'aggiunta di costrutti sintattici del linguaggio di programmazione \cite{pierceTypesBook}, evento molto più raro. Per raggirare questo problema, i linguaggi di programmazione moderni offrono costrutti sintattici per creare nuovi tipi di dato. Nei linguaggi object-oriented come Java questo equivale a definire nuove classi o interfacce, quindi ad esempio la definizione di un albero binario può essere rappresentato in questo modo:
\begin{minted}{java}
		public abstract class Tree {
			Tree left;
			Tree right;
			public boolean empty();
		}
		
		public class Branch extends Tree {
			int value;
		
			public int empty(){ return false; }
		}
		
		public class Leaf extends Tree {	
			public int empty(){ return true; }
		}
\end{minted}
Nei linguaggi funzionali questo stesso costrutto prende il nome di \textit{dichiarazione di tipo}:
\begin{minted}{haskell}
	data Tree Int = Leaf | Branch Int (Tree Int) (Tree Int)
	
	empty : Tree Int -> boolean
	empty Leaf = true
	empty _ = false
\end{minted}
L'essenza di questa dichiarazione è che si usa la parola chiave \code{data}, si dà il nome del tipo e un numero arbitrario di variabili di tipo. In questo caso, è necessario specificare \code{Int} per associare ad ogni nodo (che non sia una foglia) un valore intero. Seguono poi i valori (casi) che possono valere per gli elementi del tipo \code{Tree}: \code{Leaf} è il "caso base", una costante senza valore (è stata definita anche così nella classe Java). Il costruttore \code{Branch Int (Tree Int) (Tree Int)} è chiaramente ricorsivo, il che ci permette di costruire un albero binario profondo a piacimento. Un esempio di elemento appartenente al nuovo tipo \code{Tree} potrebbe essere \code{Branch 2 (Branch 1 Leaf Leaf) (Branch 3 Leaf Leaf)}.

Gran parte della letteratura sembra preferire i linguaggi object-oriented, in particolare Java, per sviluppare applicazioni e strumenti che utilizzano le tecnologie del Web Semantico. In effetti Java è un linguaggio di programmazione maturo, con una grossa comunità di sviluppatori e aziende che forniscono librerie e documentazione, nato oltretutto per sviluppare applicazioni che si interfaccino con il Web. Da oltre 10 anni, inoltre, è disponibile OWL API \cite{OWLAPI}, una libreria Java che espone un'insieme di procedure che consentono di creare, manipolare e serializzare ontologie OWL, oltre a parsificare e scrivere file OWL in diverse sintassi. Questa API facilita talmente tanto lo sviluppo della parte basata sulle ontologie che è ormai diventata una componente fondamentale di una vastità di tools e applicazioni, tra cui il reasoner con cui abbiamo implementato il calcolo di Leinberger nel \autoref{chap:Implementazione}, HermiT \cite{HermiTWhitepaper}. Anche Leinberger stesso, nell'implementazione in Scala della suo sistema \cite{leinbergerScalaImpl}, ha usato lo stesso reasoner. Il difetto principale dello sviluppo di software basato su ontologie rappresentate in Java è che i ragionamenti automatici sono eseguiti a run-time, cioè durante l'esecuzione del programma. Se incorrono errori a run-time riguardanti un'ontologia, come ad esempio una query SPARQL non abitata (vedere \autoref{sec:SPARQLIntro}), non c'è alcuna garanzia formale che il programma possa terminare dando il risultato desiderato \cite{leinbergerphdthesis}. Proponiamo, quindi, di sfruttare i sistemi di tipi statici in cui l'utilizzo dei tipi, controllati a tempo di compilazione, potrebbero essere una risposta ai problemi di efficienza per il controllo di certe proprietà che avrebbe senso controllare a priori, e/o nel caso di grandi quantità di dati.

\subsection{Ontologie e linguaggi funzionali}
In questa sezione, l'obiettivo della trattazione sarà di fornire una quanto più esaustiva indagine, nelle limite delle nostre capacità, sulla rappresentazione di ontologie nei linguaggi funzionali, così come evidenziare proposte di sistemi di tipi estesi in modo da integrare i costrutti logici delle ontologie basate su logiche descrittive.
L'editor di ontologie (f OWL) \cite{fOWL} scritto in un dialetto di LISP, Clojure, è presentato. Clojure è un linguaggio funzionale che compila con la Java Virtual Machine, in questo modo è altamento portabile. (f OWL) implementa la sintassi funzionale di OWL 2. Il risultato ottenuto vuole essere un'alternativa alla diffusa OWL API, scritta in Java, per quei programmatori di linguaggi funzionali interessati a l'ingegnerizzazione delle ontologie. Allo stesso tempo, promuove la lazy-evaluation dei linguaggi funzionali per semplificare la creazione e modifica di un'ontologia, come mostrato nella parte finale dell'articolo in cui vengono comparate le prestazioni di OWL API e (f OWL). Quest'ultima eccelle soprattutto nella creazione della Negation Normal Form (NNF), una pratica di normalizzazione approvata dalla comunità per andare a confrontare uniformemente l'espressività degli assiomi di classe di un largo numero di ontologie.

In questo articolo \cite{verifiableontologybasedcomputation}, le potenzialità di Haskell di implementare software corretto che ragioni su un'ontologia, in particolare della Basic Formal Ontology\footnote{\url{https://basic-formal-ontology.org/}}, sono discusse. Viene presentata una nozione di computazione basata sulle ontologie. In una parte significativa della comunità ontologica, questo concetto è associato alla dimostrazione automatica di teoremi. Gli autori introducono una nozione più ampia, che richiede che i dati di input, le trasformazioni e l'output siano coerenti con una determinata ontologia. Viene fornito un esempio che mostra come la gerarchia delle sottoclassi di un'ontologia possa essere utilizzata come vincoli di tipo in Haskell. Sebbene esistano generatori di codice OWL per linguaggi come Java, la traduzione in Haskell descritta nell'articolo fa un uso significativo del suo sistema di tipi espressivo per consentire la verifica a tempo di compilazione della concettualizzazione ontologica. Inoltre, a differenza dei linguaggi imperativi, per cui è difficile dimostrare formalmente che il calcolo sia corretto, completo e termini, in Haskell l'assenza di side effect, la dipendenza del risultato di una funzione solo dai suoi argomenti e la lazy-evaluation permettono di semplificare la verifica di questi caratteristiche per i programmi funzionali \cite{hugheswhyFPMatters}. L'articolo può essere considerato innovativo per due motivi:
\begin{enumerate}
	\item Presenta un'idea nuova, poiché non sembra esistere ancora una traduzione tipizzata dalle ontologie OWL-DL ai programmi Haskell.
	\item Avanza la proposta che potrebbe essere facile generare automaticamente il codice per rappresentare i vincoli di tipo da fornire al sistema di tipo di Haskell. In questo modo, l'evoluzione costante di un'ontologia non sarebbe affatto un problema per la manutenibilità del software che permette di ragionare sulla stessa.
\end{enumerate}


