\paragraph{} Io, Lorenzo Bafunno e Andrea Zito siamo partiti dall'idea della professoressa Bono di cercare di applicare i tipi alla rappresentazione della conoscenza. Si è poi concretizzato nel cercare di automatizzare i passaggi meccanici in modo da lasciare al programmatore solo i compiti che richiedono l'uso dell'ingegno e dell'intuizione umana.

\paragraph{} Abbiamo cominciato ad analizzare alcuni paper per prendere confidenza col mondo della rappresentazione della conoscenza, in particolare con le ontologie. Abbiamo poi analizzato in dettaglio la tesi di dottorato di Martin Gerhard Leinberger, il quale ha ideato un sistema di tipi astratto per validare le query, sistema di interrogazione delle basi della conoscenza. Del sistema di tipi di Leinberger mancava però un implementazione, e abbiamo lavorato per fornirla. Bafunno e Zito hanno sottolineato la possibiità di usare un Reasoner(sistema in grado di eseguire ragionamenti e deduzioni sulle basi di conoscena) già esistente, indicando HermiT come il più adatto. Per quanto riguarda il linguaggio da utilizzare, assieme a Zito la prima idea è stata utilizzare Haskell, un linguaggio funzionale che già conoscevamo, ma alla fine la scelta è ricaduta su OCaml, un altro linguaggio funzionale che però non conoscevamo, perché più maturo, con più librerie e più interfacciabile con il modulo Reasoner rispetto ad Haskell.

\paragraph{} Prese queste decisioni architetturali ho cominciato lo studio per conoscere meglio le due risorse che avrei poi usato nell'implementazione: Hermit e OCaml.\\
Ho studiato come utilizzare il reasoner HermiT, il che mi ha dato non pochi problemi  a causa della pochissima documentazione presente in rete. Per quanto riguarda OCaml, avendo già un background di Haskell, capire come utilizzarlo non è stato particolarmente impegnativo. \\
Ho deciso di creare due moduli, il modulo Reasoner e il modulo OCaml, il primo che performa ragionamenti sull'ontologia, mentre il secondo che implementa il sistema di tipi di Leinberger.

\paragraph{} Per l'implementazione, il mio primo problema è stato far dialogare i due moduli. La soluzione che ho trovato prevede che il modulo OCaml richiami la Shell di comando, al quale viene delegata la responsabilità di lanciare il modulo Reasoner. \\
Un altro grosso problema è stato scegliere la lingua veicolare da utilizzare per far comunicare i due moduli: il primo istinto è stato quello di definire una grammatica da zero, con tanto di parsificatore da dover usare nel Reasoner. Una scelta semplicemente troppo costosa. Allora ho provato a cercare qualche grammatica già esistente: mi sono imbattuto in una sintassi sviluppata dall'Università di Manchester per la rappresentazione di ontologie OWL, un particolare tipo di ontologie, con un parsificatore già sviluppato. Non rimaneva dunque che adattare il modulo OCaml a quella sintassi e integrare il parsificatore nel modulo Reasoner, per terminare il ponte fra i moduli.