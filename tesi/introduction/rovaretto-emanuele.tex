\chapter{Introduzione}

\section{Scopo della ricerca}
\paragraph{} Io, Lorenzo Bafunno e Andrea Zito siamo partiti dall'idea della professoressa Bono di cercare di applicare i sistemi di tipo alla rappresentazione della conoscenza. \\
% ontologie
Un particolare mezzo di rappresentazione della conoscenza sono le Ontologie, ed esse si compongono di due parti: T-Box e A-Box. La prima sono formule logiche per modellare il dominio, per esempio affermare che uno Student è una Persona. La seconda è usata per fare asserzioni su individui, per esempio affermare che Emanuele è un istanza di Persona. Un ragionamento su un Ontologia permette di eseguire inferenza sull'ontologia, per esempio inferire che se Persona ha un nome, allora anche Studente ha un nome in quanto sua sottoclasse. Le query sono il metodo per interrogare le basi di conoscenza, e si dice che una query è inabitata se non potrà mai avere un risultato. Per esempio una query che chiede le istanze di una Pizza Margherita che allo stesso tempo sia anche un Gelato, non potrà mai avere dei risultati, perché nessuna pizza è un gelato.  Una trattazione più avanzata sarà presentata nel capitolo 2

% motivazione e obbiettivo
\paragraph{} Dalla nostra indagine è emerso che le ontologie non sono più utilizzate nella loro interezza(T-Box e A-Box) perché è troppo dispendioso eseguire ragionamenti, anche se così facendo si perde molto significato non essendoci una strutturazione dei concetti. Oggigiorno infatti si utilizzano solamente gli A-Box nei meccanismi di Machine Learning. Prendendo atto di queste informazioni ci siamo chiesti se usando dei linguaggi funzionali e dei sistemi di tipo, si potesse migliorare l'efficienza delle applicazioni che manipolano ontologie spostando i controlli, che di norma vengono compiuti a run-time, a compile-time tramite i sistemi di tipaggio statico.     

\section{Il nostro lavoro}
\paragraph{} Abbiamo cominciato ad analizzare alcuni paper per prendere confidenza col mondo della rappresentazione della conoscenza, in particolare con le ontologie. Abbiamo poi analizzato in dettaglio la tesi di dottorato di Martin Gerhard Leinberger, il quale ha ideato un sistema di tipi astratto per verificare l'abitabilità delle query. Del sistema di tipi di Leinberger mancava però un implementazione, e abbiamo lavorato per fornirla. Bafunno e Zito hanno sottolineato la possibità di usare un Reasoner(sistema in grado di eseguire ragionamenti e deduzioni sulle basi di conoscena) già esistente, indicando HermiT come il più adatto. Per quanto riguarda il linguaggio da utilizzare, assieme a Zito la prima idea è stata utilizzare Haskell, un linguaggio funzionale che già conoscevamo, ma alla fine la scelta è ricaduta su OCaml, un altro linguaggio funzionale che però non conoscevamo, perché più maturo, con più librerie e più interfacciabile con il modulo Reasoner rispetto ad Haskell.

\paragraph{} Prese queste decisioni architetturali ho cominciato lo studio per conoscere meglio le due risorse che avrei poi usato nell'implementazione: Hermit e OCaml.\\
Ho studiato come utilizzare il reasoner HermiT, compito reso più arduo a causa della poca documentazione presente in rete. Per quanto riguarda OCaml, avendo già un background di Haskell, capire come utilizzarlo non è stato particolarmente impegnativo. \\

\paragraph{} Per l'implementazione, ho deciso di creare due moduli, il modulo Reasoner e il modulo OCaml, il primo che performa ragionamenti sull'ontologia, mentre il secondo che implementa il sistema di tipi di Leinberger.\\
Il mio primo problema è stato far dialogare i due moduli. La soluzione che ho trovato prevede che il modulo OCaml richiami la Shell di comando, al quale viene delegata la responsabilità di lanciare il modulo Reasoner. \\
Un altro grosso problema è stato scegliere la lingua veicolare da utilizzare per far comunicare i due moduli: il primo istinto è stato quello di definire una grammatica da zero, con tanto di parsificatore da dover usare nel Reasoner. Una scelta troppo costosa. Allora ho provato a cercare qualche grammatica già esistente: ho trovato una sintassi sviluppata dall'Università di Manchester per la rappresentazione di ontologie OWL, un particolare tipo di ontologie, con un parsificatore già implementato. Non rimaneva dunque che adattare il modulo OCaml a quella sintassi e integrare il parsificatore nel modulo Reasoner, per terminare il ponte fra i moduli.

\paragraph{} Il parsificatore e il lexer delle query nel modulo OCaml è stato facile da realizzare, perché ho usato un generatore di parser e un generatore di lexer per OCaml, OCamlyacc e OCamllex, nei quale mi è bastato specificare la grammatica della query(illustrata nel dettaglio al Capitolo 2) e la semantica dei token per ottenere il parsificatore e il lexer. L'unico intoppo l'ho registrato quando ho dovuto cercare di disambiguare la grammatica inizialmente implementata. 

\paragraph{} Il resto dell'implementazione è stato quasi immediato senza grossi problemi, dovendo solo implementare ciò che era già stato progettato da Leinberger.