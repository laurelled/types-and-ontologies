\chapter{Introduzione}

\section{Scopo della ricerca}
\paragraph{} Questo lavoro è un lavoro di gruppo svolto in collaborazione con Lorenzo Bafunno e Andrea Zito e la consulenza del dottor Marco Antonio Stranisci, della professoressa Rossana Damiano e del professor Antonio Lieto.

L'idea di partenza è stata quella di studiare i benefici dell'applicazione dei linguaggi funzionali e dei sistemi di tipi statici
 rappresentazione della conoscenza. 
 
% ontologie
Le \emph{ontologie} rappresentano un formalismo molto diffuso per la rappresentazione della conoscenza. Un'ontologia si compone di due parti: \emph{T-Box} ( Terminology Box) e \emph{A-Box} (Assertion Box). La prima contiene formule logiche per modellare il dominio, per esempio per affermare che uno 'Studente' è una 'Persona'. La seconda è usata per esprimere asserzioni su individui, per esempio affermare che 'Emanuele' è un istanza di 'Persona'. Un ragionamento su un'ontologia è inferenza di proprietà di interesse, per esempio se si inferisce che 'Persona' ha un nome, allora anche 'Studente' ha un nome, in quanto sua sottoclasse. Le basi di conoscenza rappresentate da ontologie vengono interrogate tramite \emph{query}. Si dice che una query è \emph{abitata} (\emph{inhabited}) se  restituisce dei risultati. Per esempio, una query che cerca le istanze di una 'Pizza Margherita' che allo stesso tempo sia anche un 'Gelato', non è abitata perché potrà mai avere dei risultati, perché nessuna pizza è un gelato (almeno in una base di conoscenza basata sul senso comune).  Una trattazione più avanzata sul tema sarà presentata nel Capitolo \ref{chap:preliminaries}.

% motivazione e obbiettivo
\paragraph{} Dalla nostra indagine (si veda per esempio \cite{baader2017introductionDL}), è emerso che le ontologie non sono più utilizzate nella loro interezza (T-Box e A-Box) perché è troppo dispendioso eseguire ragionamenti formali complessi, anche se così facendo si perde espressività, ignorando una strutturazione più sofisticata dei concetti. Oggigiorno infatti si tende a utilizzare solamente gli A-Box, ovvero le asserzioni sugli individui, per esempio come dati per i modelli basati sul machine learning. Ci siamo quindi chiesti se fosse possibile costruire formalismi che recuperino parte dell'espressività dei ragionamenti formali, senza perdere troppo in efficienza. Una strada che riteniamo promettente è l'uso dei linguaggi funzionali e dei sistemi di tipo per creare applicazioni e nuovi linguaggi che manipolano ontologie spostando i controlli, che di norma vengono compiuti a run-time, a compile-time tramite i sistemi di tipaggio statico.     

\section{Il nostro lavoro}
\paragraph{} Abbiamo cominciato ad analizzare alcuni lavori appartenenti alla letteratura sulla rappresentazione della conoscenza, in particolare sulle ontologie. Abbiamo poi analizzato in dettaglio la tesi di dottorato di Martin Gerhard Leinberger \cite{leinbergerphdthesis}, il quale ha ideato un calcolo con sistema di tipi statico per verificare l'abitabilità delle query SPARQL-CQ trattato nel capitolo \ref{chap:preliminaries}. Noi abbiamo deciso di implementarlo. Bafunno e Zito hanno sottolineato la possibilità di usare un Reasoner (ovvero un sistema in grado di eseguire ragionamenti e deduzioni sulle basi di conoscena) già esistente, indicando HermiT come il più adatto. Per quanto riguarda il linguaggio da utilizzare, assieme a Zito, la prima idea è stata utilizzare Haskell, un linguaggio funzionale che già conoscevamo, ma alla fine la scelta è ricaduta su OCaml (che abbiamo studiato appositamente), un altro linguaggio funzionale più maturo, con più librerie e più interfacciabile con il modulo Reasoner rispetto ad Haskell. 

\paragraph{} Prese queste decisioni architetturali, ho cominciato lo studio per conoscere meglio le due risorse che avrei poi usato nell'implementazione: Hermit \cite{HermiT} e OCaml \footnote{www.ocaml.org}.\\
Ho studiato come utilizzare il reasoner HermiT, compito reso più arduo a causa della poca documentazione presente in rete. Per quanto riguarda OCaml, avendo già un background di Haskell, capire come utilizzarlo non è stato particolarmente impegnativo. \\

\paragraph{} Per l'implementazione, ho deciso di creare due moduli, il modulo Reasoner, scritto in Java, e il modulo OCaml, il primo che performa ragionamenti sull'ontologia, mentre il secondo che implementa il sistema di tipi di Leinberger.

Il mio primo problema è stato far dialogare i due moduli. La soluzione che ho trovato prevede che il modulo OCaml richiami la shell di comando, al quale viene delegata la responsabilità di lanciare il modulo Reasoner.

Un altro grosso problema è stato scegliere la "lingua veicolare" da utilizzare per far comunicare i due moduli: la prima idea è stata quella di definire una grammatica da zero, con tanto di parsificatore da dover usare nel Reasoner: una scelta troppo costosa. Allora ho provato a cercare qualche grammatica già esistente: ho trovato una sintassi sviluppata dall'Università di Manchester per la rappresentazione di ontologie OWL, un particolare tipo di ontologie, con un parsificatore già implementato \footnote{https://ceur-ws.org/Vol-216/submission_9.pdf}. Non rimaneva dunque che adattare il modulo OCaml a quella sintassi e integrare il parsificatore nel modulo Reasoner, per terminare il ponte fra i moduli.

\paragraph{} Il parsificatore e il lexer delle query nel modulo OCaml sono stati facili da realizzare, perché ho usato un generatore di parser e un generatore di lexer per OCaml, OCamlyacc e OCamllex, nei quale mi è bastato specificare la grammatica della query (illustrata nel dettaglio al Capitolo \ref{chap:preliminaries}) e la semantica dei token per ottenere il parsificatore e il lexer. L'unico intoppo l'ho registrato quando ho dovuto cercare di disambiguare la grammatica inizialmente implementata. 

\paragraph{} Il resto dell'implementazione è stato quasi immediato senza grossi problemi, dovendo solo implementare ciò che era già stato progettato da Leinberger.

Attorno al lavoro sull'implementazione del modulo delle query di Leinberger, riassunto sopra nella tesi si trovano:
\begin{itemize}
\item il lavoro di rassegna della letteratura sui tipi e Web Semantico, di cui si è occupato essenzialmente Lorenzo Bafunno (Capitolo \ref{chap:State-of-art});
\item l'implementazione del resto del calcolo di Leinberger, creata principalmente da Andrea Zito (Capitolo \ref{chap:Implementazione});
\item le direzioni di ricerca future, che nascono da riflessioni corali, supportate dal dottor Marco Antonio Stranisci, dalla professoressa Rossana Damiano e dal professor Antonio Lieto (Capitolo \ref{chap:FutureWork}).
\end{itemize}