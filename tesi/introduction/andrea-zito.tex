La tesi è stata svolta in collaborazione con Lorenzo Bafunno e Emanuele Rovaretto.
\section{Programmazione funzionale}
    La programmazione funzionale è un paradigma che permette di scrivere in modo naturale programmi di semplice lettura e dubugging grazie sopratutto all'assenza di side-effect nelle funzioni.
    I side-effect o in italiano effetti collaterali, si verificano quando si modifica lo stato di variabili al di fuori dello scope locale. Ad esempio una semplice funzione java
    \begin{minted}{java}
    void move(Poitn p){
        p.x++;
        p.y++;
    }
    \end{minted} 
    che prende in input un oggetto \code{Point p} con attributi \code{float x} e \code{float y}. Quando eseguito, essendo \code{p} un oggetto, viene passato per riferimento
    quindi provocando la modifica dello stato dell'oggetto anche al di fuori dello scope di \code{void move(Point p)}. Linguaggi funzionali come Haskell non
    permetto la creazione di funzioni inpure come \code{move}, ma costringono il programmatore a non produrre side-effect.
    \begin{minted}{haskell}
    type Point = (Float, Float)
    move :: Point -> Point
    move (x, y) = (x + 1, y + 1)
    \end{minted}
    In questo caso \code{move} ritorna un nuovo \code{Point} con gli attributi \code{x} e \code{y} incrementati di \code{1}, senza modificare lo stato di alcuna
    variabile.
    \\I linguaggi funzionali sono molto versatili sopratutto grazie alla possibilità di avere funzioni di ordine superiore, ovvero delle funzioni che come parametro
    hanno altre funzioni. Un caso tipico di utilizzo di funzioni di ordine superiore è l'implementazione della funzione \code{map}.
    \begin{minted}{haskell}
    map :: (a -> b) -> [a] -> [b]
    map _ []     = []
    map f (x:xs) = f x : map f xs
    \end{minted}
    \code{map} prende in input una funzione \code{(a -> b)} e una lista di oggetti di tipo \code{a} (\code{[a]}) e ritorna una lista di oggetti di tipo \code{b} (\code{[b]}). 
    la funzione passata come parametro, \code{f}, viene applicata ricorsivamente ad ogni elemento della lista \code{f x : map f xs} generando così la lista risultante. 
    Nei due esempi precedenti abbiamo usato silenziosamente un'altra feature molto utilizzata nei linguaggi funzionali: il pattern matching.
    \code{move (x, y) = (x + 1, y + 1)} confronta l'argomento della funzione con i pattern. In questo caso l'argomento è di tipo \code{Point} ovvero
    una coppia di \code{Float}, quindi quando si scrive \code{move (x, y) = ...}, \code{x} e \code{y} avranno i valori dei campi dell'oggetto \code{Point}
    che potremo liberamente usare nel body della funzione (\code{(x + 1, y + 1)}).
    La funzione \code{map} sfrutta il pattern mathing per distinguere il caso in cui la lista è vuota \code{map _ []} (caso base della ricorsione), dal caso in cui
    bisogna applicarre la ricorsione sulla lista \code{map f (x:xs)}. 
    \\I linguaggi funzionali sono spesso accompagnati da uno stretto ma flessibile sistema di tipi
    che permette di catturare a tempo di compilazione molti errori che altrimenti ritroveremmo a runtime. I data type creati in linguaggi come Haskell o OCaml
    permettono di creare tipi al programmatore dandogli così molta flessibilità mentenendo i controlli statici. per esempio con il tipo \code{Nat}
    \begin{minted}{haskell}
        data Nat = zero | Succ Nat
    \end{minted}
    si sono definiti i numeri naturali con cui, attraverso il pattern matching, è possibile creare semplicemente funzioni che operano su di essi:
    \begin{minted}{haskell}
        (+) :: Nat -> Nat -> Nat
        zero     + y = x
        (Succ x) + y = succ (x + y) 
    \end{minted}
    la funzione \code{(+)} che esegue semplicemente l'addizione su due numeri naturali, anche se molto in piccolo, mostra l'eleganza, la chiarezza e le potenzialita dei linguaggi funzionali.
    Per i motivi descritti sopra i linguaggi funzionali sembrano adatti per la costruzione di formalismi e strumenti per supportare un reasoning efficiente
    nell'ambito della knowledge representation.
\section{Semantic Web}
Il Web Semantico fornisce un framework comune che consente la condivisione e il riutilizzo dei dati al di là dei confini delle applicazioni.
 È uno sforzo collaborativo guidato dall'organizzazione W3C\footnote{\url{https://www.w3.org/about/}} con la partecipazione di un gran numero di ricercatori 
 e partner industriali. Gli obiettivi principali del Web Semantico \cite{berners2001semantic, hitzler2021review} sono due:
\begin{enumerate}[I)]
	\item creare una rete di dati interconnessi, in contrapposizione all'attuale Web basato sui documenti;
	\item permettere che una macchina possa comprendere le informazioni disponibili sul Web senza intervento umano.
\end{enumerate}
Per soddisfare entrambi, si è resa necessaria l'introduzione di annotazioni espressive che spieghino la correlazione fra i dati, ed è per questo che W3C ha 
introdotto il \textit{Resource Description Framework} (RDF) \cite{RDFspecification}. RDF è uno standard che permette la codifica, lo scambio e il riutilizzo 
di metadati (dati che descrivono altri dati), strutturandoli come dichiarazioni di triple soggetto, predicato e oggetto. In questo modo RDF permette di 
rappresentare dei grafi, i cui nodi e vertici rappresentano informazioni presenti nel web (chiamate \textit{risorse}) e sono identificate dagli IRI, 
identificatori unici di risorse che svolgono la stessa funzione degli URL per i documenti web. Essendo unici, essi consentono di associare ai nodi di due 
grafi diversi la stessa risorsa. Per condividere la terminologia (e.g. cosa s'intende per "Studente") è stato proposto da W3C un ulteriore standard, le 
ontologie OWL. In generale, le ontologie sono rappresentazioni formali, condivise ed esplicite di una concettualizzazione di un dominio di interesse 
\cite{goy2015ontologies} in maniera complessa e strutturata. OWL (\textit{Ontology Web Language}) è un linguaggio altamente espressivo e formale basato su 
logiche appartenenti al campo della knowledge representation (KR), le logiche descrittive (DL) \cite{baader2017introductionDL}. La forma logica delle 
ontologie OWL di definire un ragionamento automatico basato su inferenze, cioè dedurre nuove informazioni basandosi su quelle che sappiamo essere vere.
La definizione del dominio d'interesse tramite ontologie permette di aggiungere ulteriore struttura ai dati espressi nei grafi RDF, specificandone uno schema. 
In questo senso, a volte, ci si riferisce alle ontologie come a dei “sistemi di tipi” per tali dati. Un sistema di tipo, nei linguaggi di programmazione, 
è un sistema logico che permette di assegnare a ogni termine un tipo, che identifica le caratteristiche e i valori possibili di quel termine. Storicamente, 
le ontologie basate su DL comprendono almeno due tipologie di asserzioni:
\begin{enumerate}[i)]
	\item dichiarazioni di concetti, che vanno a svolgere il ruolo di "tipo" per i nodi RDF, e la loro gerarchia. L'insieme di tutte queste definizioni 
    è detto \textsc{\itshape T-Box}. Essa contiene quindi tutta la parte di terminologia, ovvero le \textit{condizioni necessarie e sufficienti} per un 
    elemento di far parte di un concetto.
	\item asserzioni sugli individui o di sussistenza di una proprietà. Ad esempio, dire che \textsl{Elena} è una Persona, oppure che la 
    \textsl{ Pizza margherita} ha come ingrediente \textsl{Pomodoro}. L'insieme di queste asserzioni è detto \textsc{\itshape A-Box}, e rappresenta 
    tutte le "istanze" rilevanti per la realtà descritta.
\end{enumerate}
Grazie alla descrizione tramite formalismi logici, le ontologie permettono inferenze automatiche sulla tassonomia definita e sui dati che ne fanno uso. 
Per ragioni di efficienza, però, nel campo del Web Semantico è diventato d'uso comune abbandonare il ragionamento formale delle ontologie per passare ai 
più efficienti ragionamenti sub-logici dei modelli di machine learning, usando come input le asserzioni presenti nell'\textsc{\itshape A-Box} rappresentate 
come grafi RDF, meno espressivi e quindi efficienti. Questo è dato dal fatto che la rappresentazione logica, per quanto formalmente decidibile, ha una 
complessità talmente elevata da rendere il ragionamento logico inutilizzabile per la mole di dati che le applicazioni hanno necessità di usare 
\cite{baader2017introductionDL}. Tuttavia, la nostra convinzione è che possano esserci delle potenzialità da sfruttare nei sistemi di tipi statici nel 
campo della knowldege representation, in modo da ritornare a svolgere un ragionamento formale e riproducibile, recuperando parte dell'efficienza e 
dell'espressività persa.
\section{Scopo della tesi}
Il nostro lavoro esmplora possibili proposte nella direzione di fornire strumenti formali basati su linguaggi funzionali tipati per supportare un reasoning
espressivo e efficiente sui dati semanticamente annotati. Si pone sempre più, infatti, il problema di avere efficienza e, nel contempo, offrire semantiche 
espressive, per i dati in formato Resource Description Framework (RDF). La struttura semantica aggiunta dalle ontologie ai grafi RDF \'e sempre meno utilizzata
in favore di tecniche sub-logiche, legate soprattutto al machine learning che sfruttano soprattutto le asserzioni sugli individui (A-Box). 
I tipi e i linguaggi funzionali sembrano avere ottime potenzialità per recuperare la complessità sia dei T-Box che A-Box, aggiungendo controlli statici
ma mantenendo l'efficienza necessaria.
\section{Il nostro lavoro}
    La fase iniziale del lavoro era l'esplorazione del dominio di ricerca,
    studiando le basi delle ontologie e grafi RDF dai materiali dal corso "Modellazione Concettuale per il Web Semantico" della professoressa Rossana Damiano.
    Successivamente ci siamo informatati sugli sforzi già fatti sull'uso dei sistemi tipi per il web semantico e in particolare ci siamo concentrati sulla tesi di
    dottorato "Type-safe Programming for the Semantic Web" di Martin Leinberger che propone un linguaggio di programmazione ($\lambda_{DL}$) per lavorare sulle ontologie con 
    controlli di tipo statici. Da questo punto in poi, avendo tutti le idee leggermente più chiare, ci siamo divisi i compiti. In particolare Lorenzo si
    è occupato di continuare la ricerca e studio delle pubblicazioni nel nostro ambito. Io ed Emanule invece ci siamo concentrati sulla implementazione
    del $\lambda_{DL}$: io mi sono occupato del type system del linguaggio mentre Emanuele del tipaggio e esecuzione delle Query SPARQL.
    Il mio lavoro è stato inanzitutto capire il linguaggio da utilizzare per l'implementazione. I primi esperimenti sono stati in Haskell, ma siccome le librerie
    sull'integrazione di reasoner su ontologie sono poche e non offrono le funzionalità che ci servivano, abbiamo optato di passare a OCaml, sotto suggerimento della professoressa e relatrice Viviana Bono. 
    Prima di passare direttamente alla scrittura del codice ho letto il libro "Types and Programming Languages" di Benjamin C. Pierce dove spiega da un punto di vista
    più ingegneristico i sitemi di tipi e mostra passo passo come implementare un linguaggio di programmazione basato sul $\lambda$-calco utilizzando OCaml.
    Con tutto lo studio preliminare, la scrittura del codice è stata molto diretta, senza incontrare grosse difficoltà.
    \\L'implementazione si è rilevata molto utile per aiutarmi a comprendere meglio come le ontologie vengono usate e le potenzialità che offrono chiarendochiarendo anche
    quali sono gli attuali problemi che si presentano quando si lavora sulle ontologie e come i tipi possono essere di aiuto. Inoltre l'implementazione è stato un ottimo
    esercizio di programmazione funzionale e di conoscienza dei linguaggi di programmazione.
    \\Il lavoro di tesi si è concluso con un'ultima grossa parte in cui insieme a Emanuele e Lorenzo abbiamo esposto i nostri lavori e ascolatato le idee e opinioni degli esperti
    di Web Semantico Marco Antonio Stranisci, Antonio Lieto e Rossana Damiano. Da questi incontri sono stati chiariti molti dubbi e sono nate anche molte idee che verranno
    spiegate nella sezione di Future Works della tesi. Gli argomenti trattati sono vari e necessiterebbero molta più investigazione, le potenzialità della ricerca esistono
    e sono attualmente poco esplorate. 