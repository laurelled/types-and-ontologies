\textsl{Questo lavoro è stato fatto in collaborazione con Andrea Zito e Emanuele Rovaretto, sotto la supervisione della professore e relatrice Viviana Bono.}\\\\
Il World Wide Web è diventato una consolidata rete di conoscenza, ma già a partire dalla sua nascita presenta il difetto di essere pensato per la sola fruizione umana. Il linguaggio di rappresentazione delle centinaia di pagine che visitiamo ogni giorno, HTML, descrive soltanto l’impaginazione delle informazioni visualizzate dall'utente. Senza una struttura che spieghi il significato dei dati presentati, un agente intelligente non può comprendere la maggior parte delle informazioni presenti in rete. 
Il Web Semantico fornisce un framework comune che consente la condivisione e il riutilizzo dei dati al di là dei confini delle applicazioni. È uno sforzo collaborativo guidato dall'organizzazione W3C\footnote{\url{https://www.w3.org/about/}} con la partecipazione di un gran numero di ricercatori e partner industriali. Gli obiettivi principali del Web Semantico \cite{berners2001semantic, hitzler2021review} sono due:
\begin{enumerate}[I)]
	\item creare una rete di dati interconnessi, in contrapposizione all'attuale Web basato sui documenti;
	\item permettere che una macchina possa comprendere le informazioni disponibili sul Web senza intervento umano.
\end{enumerate}
Per soddisfare entrambi, si è resa necessaria l'introduzione di annotazioni espressive che spieghino la correlazione fra i dati, ed è per questo che W3C ha introdotto il \textit{Resource Description Framework} (RDF) \cite{RDFspecification}. RDF è uno standard che permette la codifica, lo scambio e il riutilizzo di metadati (dati che descrivono altri dati), strutturandoli come dichiarazioni di triple soggetto, predicato e oggetto. In questo modo RDF permette di rappresentare dei grafi, i cui nodi e vertici rappresentano informazioni presenti nel web (chiamate \textit{risorse}) e sono identificate dagli IRI, identificatori unici di risorse che svolgono la stessa funzione degli URL per i documenti web. Essendo unici, essi consentono di associare ai nodi di due grafi diversi la stessa risorsa. Per condividere la terminologia (e.g. cosa s'intende per "Studente") è stato proposto da W3C un ulteriore standard, le ontologie OWL. In generale, le ontologie sono rappresentazioni formali, condivise ed esplicite di una concettualizzazione di un dominio di interesse \cite{goy2015ontologies} in maniera complessa e strutturata. OWL (\textit{Ontology Web Language}) è un linguaggio altamente espressivo e formale basato su logiche appartenenti al campo della knowledge representation (KR), le logiche descrittive (DL) \cite{baader2017introductionDL}. La forma logica delle ontologie OWL di definire un ragionamento automatico basato su inferenze, cioè dedurre nuove informazioni basandosi su quelle che sappiamo essere vere.

La definizione del dominio d'interesse tramite ontologie permette di aggiungere ulteriore struttura ai dati espressi nei grafi RDF, specificandone uno schema. In questo senso, a volte, ci si riferisce alle ontologie come a dei “sistemi di tipi” per tali dati. Un sistema di tipo, nei linguaggi di programmazione, è un sistema logico che permette di assegnare a ogni termine un tipo, che identifica le caratteristiche e i valori possibili di quel termine. Storicamente, le ontologie basate su DL comprendono almeno due tipologie di asserzioni:
\begin{enumerate}[i)]
	\item dichiarazioni di concetti, che vanno a svolgere il ruolo di "tipo" per i nodi RDF, e la loro gerarchia. L'insieme di tutte queste definizioni è detto \textsc{\itshape T-Box}. Essa contiene quindi tutta la parte di terminologia, ovvero le \textit{condizioni necessarie e sufficienti} per un elemento di far parte di un concetto.
	\item asserzioni sugli individui o di sussistenza di una proprietà. Ad esempio, dire che \textsl{Elena} è una Persona, oppure che la \textsl{ Pizza margherita} ha come ingrediente \textsl{Pomodoro}. L'insieme di queste asserzioni è detto \textsc{\itshape A-Box}, e rappresenta tutte le "istanze" rilevanti per la realtà descritta.
\end{enumerate}
Grazie alla descrizione tramite formalismi logici, le ontologie permettono inferenze automatiche sulla tassonomia definita e sui dati che ne fanno uso. Per ragioni di efficienza, però, nel campo del Web Semantico è diventato d'uso comune abbandonare il ragionamento formale delle ontologie per passare ai più efficienti ragionamenti sub-logici dei modelli di machine learning, usando come input le asserzioni presenti nell'\textsc{\itshape A-Box} rappresentate come grafi RDF, meno espressivi e quindi efficienti. Questo è dato dal fatto che la rappresentazione logica, per quanto formalmente decidibile, ha una complessità talmente elevata da rendere il ragionamento logico inutilizzabile per la mole di dati che le applicazioni hanno necessità di usare \cite{baader2017introductionDL}. Tuttavia, la nostra convinzione è che possano esserci delle potenzialità da sfruttare nei sistemi di tipi statici in modo da ritornare a svolgere un ragionamento formale e riproducibile, recuperando parte dell'efficienza e dell'espressività persa.
\newpage
\section{Programmazione funzionale}
La programmazione funzionale è un paradigma che permette di scrivere in modo naturale programmi di semplice lettura e dubugging grazie sopratutto all'assenza di side-effect nelle funzioni.
I side-effect o in italiano effetti collaterali, si verificano quando si modifica lo stato di variabili al di fuori dello scope locale. Ad esempio una semplice funzione Java
\begin{minted}{java}
	void move(Point p){
		p.x++;
		p.y++;
	}
\end{minted} 
che prende in input un oggetto \code{Point p} con attributi \code{float x} e \code{float y}. Quando eseguito, essendo \code{p} un oggetto, viene passato per riferimento
quindi provocando la modifica dello stato dell'oggetto anche al di fuori dello scope di \code{void move(Point p)}. Linguaggi funzionali come Haskell \cite{...} non
permetto la creazione di funzioni inpure come \code{move}, ma costringono il programmatore a non produrre side-effect.
\begin{minted}{haskell}
	type Point = (Float, Float)
	move :: Point -> Point
	move (x, y) = (x + 1, y + 1)
\end{minted}
In questo caso \code{move} ritorna un nuovo \code{Point} con gli attributi \code{x} e \code{y} incrementati di \code{1}, senza modificare lo stato di alcuna
variabile.
\\I linguaggi funzionali sono molto versatili sopratutto grazie alla possibilità di avere funzioni di ordine superiore, ovvero delle funzioni che come parametro
hanno altre funzioni. Un caso tipico di utilizzo di funzioni di ordine superiore è l'implementazione della funzione \code{map}.
\begin{minted}{haskell}
	map :: (a -> b) -> [a] -> [b]
	map _ []     = []
	map f (x:xs) = f x : map f xs
\end{minted}
\code{map} prende in input una funzione \code{(a -> b)} e una lista di oggetti di tipo \code{a} (\code{[a]}) e ritorna una lista di oggetti di tipo \code{b} (\code{[b]}). 
la funzione passata come parametro, \code{f}, viene applicata ricorsivamente ad ogni elemento della lista \code{f x : map f xs} generando così la lista risultante. 
Nei due esempi precedenti abbiamo usato silenziosamente un'altra feature molto utilizzata nei linguaggi funzionali: il pattern matching.
\code{move (x, y) = (x + 1, y + 1)} confronta l'argomento della funzione con i pattern. In questo caso l'argomento è di tipo \code{Point} ovvero
una coppia di \code{Float}, quindi quando si scrive \code{move (x, y) = ...}, \code{x} e \code{y} avranno i valori dei campi dell'oggetto \code{Point}
che potremo liberamente usare nel body della funzione (\code{(x + 1, y + 1)}).
La funzione \code{map} sfrutta il pattern mathing per distinguere il caso in cui la lista è vuota \code{map _ []} (caso base della ricorsione), dal caso in cui
bisogna applicarre la ricorsione sulla lista \code{map f (x:xs)}. 
\\I linguaggi funzionali sono spesso accompagnati da uno stretto ma flessibile sistema di tipi statico, che permette di catturare a tempo di compilazione molti errori che altrimenti ritroveremmo a runtime. I data type creati in linguaggi come Haskell \cite{...} o OCaml \cite{...}
permettono di creare tipi al programmatore dandogli così molta flessibilità mentenendo i controlli statici. per esempio con il tipo \code{Nat}
\begin{minted}{haskell}
	data Nat = zero | Succ Nat
\end{minted}
si sono definiti i numeri naturali con cui, attraverso il pattern matching, è possibile creare semplicemente funzioni che operano su di essi:
\begin{minted}{haskell}
	(+) :: Nat -> Nat -> Nat
	zero     + y = x
	(Succ x) + y = succ (x + y) 
\end{minted}
la funzione \code{(+)} che esegue semplicemente l'addizione su due numeri naturali, anche se molto in piccolo, mostra l'eleganza, la chiarezza e le potenzialita dei linguaggi funzionali.
Per i motivi descritti sopra i linguaggi funzionali sembrano adatti per la costruzione di formalismi e strumenti per supportare un reasoning efficiente
nell'ambito della knowledge representation.
\section{Scopo della tesi}
Questo lavoro si propone come uno studio preliminare per sottoporre alla comunità scientifica del Web Semantico possibili proposte nella direzione di \textsl{fornire strumenti formali basati su linguaggi funzionali staticamente tipati}. Utilizzare strumenti logici come i sistemi di tipi per fare ragionamento potrebbe sembrare una direzione di ricerca che va nel senso contrario rispetto alla preferenza corrente dell'applicazione di tecniche sub-logiche legate soprattutto al machine learning, molto più efficienti. Sebbene l'efficienza sia un aspetto chiave di un processo di computazione, non è l'unico fattore.
L'obiettivo di questa tesi è duplice: 
\begin{enumerate}[I)]
	\item fornire una panoramica preliminare dello stato d'arte relativo alla ricerca sull'uso dei sistemi di tipi statici nel contesto del Web Semantico e della rappresentazione di conoscenza;
	\label{itm:I}
	\item  attraverso lo studio e implementazione, principalmente da parte di Andrea Zito e Emanuele Rovaretto, del sistema $\lambda_{DL}$ di Martin Leinberger introdotto nella sua tesi di dottorato "Type-safe Programming for the Semantic Web" \cite{leinbergerphdthesis}, e alcuni proficui scambi con Marco Antonio Stranisci, Rossana Damiano e Antonio Lieto del Dipartimento di Informatica dell’Università di Torino, proporre possibili direzioni future per l’utilizzo di linguaggi funzionali staticamente tipati per programmare applicazioni che manipolano le ontologie e lo studio di sistemi di tipi statici che garantiscano proprietà interessanti ai programmi che svolgono computazioni basate su ontologie, certificati dal sistema di tipi stesso.
\end{enumerate}
\newpage
\noindent
Attualmente, gran parte dei processi di ragionamento basati su un'ontologia sono eseguiti a run-time, cioè durante l'esecuzione del programma, usando librerie Java come OWL API \cite{OWLAPI} per rappresentare gli assiomi ontologici nei linguaggi di programmazione object-oriented e sfruttarli per fare inferenza. Se incorrono errori a run-time dovuti all'ontologia, non c'è alcuna garanzia formale che il programma possa terminare dando il risultato desiderato. In contesti in cui le informazioni sono di vitale importanza si vorrebbe avere una garanzia concreta che i risultati siano quelli attesi. Proponiamo, quindi, di sfruttare i sistemi di tipi statici in cui l'utilizzo dei tipi, controllati a tempo di compilazione, potrebbe essere una risposta ai problemi di efficienza per certe proprietà che avrebbe senso controllare a priori, e/o nel caso di grandi quantità di dati. La tesi di dottorato di Martin Leinberger \cite{leinbergerphdthesis} che abbiamo approfondito in questo lavoro, focus principale dell'implementazione nel \autoref{chap:Implementazione}, è certamente un esempio di iniziativa verso questa direzione, poichè propone un lambda-calcolo con tipi statici per decidere a tempo di compilazione se una query SPARQL è abitata, ovvero se produrrà un risultato quando interpretata, per assicurare il suo utilizzo a tempo di esecuzione. Il nostro lavoro di implementazione ci ha dato qualche indicazione anche relativamente al \autoref{itm:I}, come ad esempio scoprire che OCaml \cite{...} fosse un linguaggio più fornito di librerie per il parsing e meno complesso di Haskell \cite{...}.


